# -*- coding: utf-8 -*-# -*- encoding: utf-8 -*-# -*- encoding: gbk -*-# @Author: niu# @Date:   2019-08-20 09:44:16# @Last Modified by:   niu# @Last Modified time: 2019-08-22 18:42:21from imapclient import IMAPClientimport pyzmailimport pprintimport timeimport pickleimport socketclass Imapmail(object):    # 初始化数据    def __init__(self):        self.serveraddress = None        self.user = None        self.passward = None        self.prot = None        self.ssl = None        self.timeout = None        self.savepath = None        self.server = None        self.previous = 0        self.white_list = ['0']        self.black_list = ['0']        self.junk_list = ['0']        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 与算法建立连接    def algorithm_socket(self):        self.s.bind(('localhost', 6999))        self.s.listen(5)        while True:            conn, addr = self.s.accept()            while True:                try:                    data = conn.recv(1024)                    print(data.decode())                    conn.send(data.upper())                except ConnectionResetError as e:                    print('连接已关闭！', str(e))                    break            conn.close()    # 从本地读取白名单、黑名单    def load_list_from_file(self):        with open('white_list.pkl', 'rb') as wf:            self.white_list = pickle.load(wf)        with open('black_list.pkl', 'rb') as bf:            self.black_list = pickle.load(bf)        with open('junk_list.pkl', 'rb') as jf:            self.junk_list = pickle.load(jf)    # 从本地读取白名单、黑名单    def save_list_to_file(self):        with open('white_list.pkl', 'wb') as wf:            pickle.dump(self.white_list, wf)        with open('black_list.pkl', 'wb') as bf:            pickle.dump(self.black_list, bf)        with open('junk_list.pkl', 'wb') as jf:            pickle.dump(self.junk_list, jf)    # 链接    def client(self, user, passward):        self.user = user        self.passward = passward        if self.user.endswith("@163.com"):            self.serveraddress = "imap.163.com"  # 邮箱地址        elif self.user.endswith("@qq.com"):            self.serveraddress = "imap.qq.com"        elif self.user.endswith("@qq.com"):            self.serveraddress = "imap.126.com"        else:            pass        self.savepath = "C:/Qt"  # 邮件存放路径        try:            self.server = IMAPClient(                self.serveraddress, self.prot, self.ssl, timeout=self.timeout)            return self.server        except BaseException as e:            return "ERROR: >>> " + str(e)    # 认证    def login(self):        try:            self.server.login(self.user, self.passward)            self.previous = imap.get_mails_num('INBOX', 'ALL')            pprint.pprint(self.server.list_folders())        except BaseException as e:            return "ERROR: >>> " + str(e)    # 获取目录列表 [((), b'/', 'INBOX'), ((b'\\Drafts',), b'/', '草稿箱'),]    def get_mail_dir(self):        dirlist = self.server.list_folders()        return dirlist    # 获取邮件数    def get_mails_num(self, boxname, tag):        self.server.select_folder(boxname, readonly=True)        result = self.server.search(tag)        return len(result)    # 获取新收到的邮件    def get_new_mails(self):        self.server.select_folder('INBOX', readonly=False)        result = self.server.search('ALL')        for _sm in result[self.previous:len(result)]:            data = self.server.fetch(_sm, ['ENVELOPE'])            # size = self.server.fetch(_sm, ['RFC822.SIZE'])            envelope = data[_sm][b'ENVELOPE']            # print(envelope)            dates = envelope.date            msgdict = self.server.fetch(_sm, ['BODY[]'])  # 获取邮件内容            mailbody = msgdict[_sm][b'BODY[]']  # 获取邮件内容            messageObj = pyzmail.PyzMessage.factory(mailbody)            subject = messageObj.get_subject()            print("主题：", subject)            print("时间：", dates)            # print("大小：", size)            if messageObj.get_addresses('from')[0][1] in self.black_list:                # self.server.copy(_sm, '已删除')                self.add_junk_list(_sm)                # self.server.delete_messages(_sm)            else:                self.server.set_flags(_sm, 'UNSEEN')            print("发方：", messageObj.get_addresses(                'from'))  # [0][0]为用户名，[0][1]为用户邮箱            print("收方：", messageObj.get_addresses('to'))            # pprint.pprint(messageObj.get_addresses('cc'))            # pprint.pprint(messageObj.get_addresses('bcc'))            if messageObj.text_part != None:                messageConten = messageObj.text_part.get_payload().decode(                    messageObj.text_part.charset)                print("内容：", messageConten)            elif messageObj.html_part != None:                messageConten = messageObj.html_part.get_payload().decode(                    messageObj.html_part.charset)                print("内容：", messageConten)            else:                pass        self.previous = self.get_mails_num('INBOX', 'ALL')    # 获取所有邮件    def get_all_mails(self):  # 收取所有邮件        print(self.server)        # 选择目录 readonly=True 只读,不修改,这里只选择了 收件箱        self.server.select_folder('INBOX', readonly=True)        result = self.server.search('ALL')  # 获取所有邮件总数目 [1,2,3,....]        print("邮件列表:", result)        for _sm in result:            data = self.server.fetch(_sm, ['ENVELOPE'])            size = self.server.fetch(_sm, ['RFC822.SIZE'])            envelope = data[_sm][b'ENVELOPE']            # print(envelope)            dates = envelope.date            msgdict = self.server.fetch(_sm, ['BODY[]'])  # 获取邮件内容            mailbody = msgdict[_sm][b'BODY[]']  # 获取邮件内容            messageObj = pyzmail.PyzMessage.factory(mailbody)            subject = messageObj.get_subject()            print("主题：", subject)            print("时间：", dates)            print("大小：", size)            print("发方：", messageObj.get_addresses('from'))            print("收方：", messageObj.get_addresses('to'))            # pprint.pprint(messageObj.get_addresses('cc'))            # pprint.pprint(messageObj.get_addresses('bcc'))            if messageObj.text_part != None:                messageConten = messageObj.text_part.get_payload().decode(                    messageObj.text_part.charset)                print("内容：", messageConten)            elif messageObj.html_part != None:                messageConten = messageObj.html_part.get_payload().decode(                    messageObj.html_part.charset)                print("内容：", messageConten)            else:                pass    def add_white_list(self, mailbox):        self.white_list.append(mailbox)    def add_black_list(self, mailbox):        self.black_list.append(mailbox)    def add_junk_list(self, mail):        self.junk_list.append(mail)    def close(self):        self.server.logout()if __name__ == "__main__":    imap = Imapmail()    imap.client("Illucia_Niu@163.com", "321324543x")    imap.login()    # imap.save_list_to_file()    # imap.get_all_mails()    # start = time.perf_counter()    while True:        if imap.previous < imap.get_mails_num('INBOX', 'ALL'):            imap.get_new_mails()            pass        elif imap.previous > imap.get_mails_num('INBOX', 'ALL'):            imap.previous = imap.get_mails_num('INBOX', 'ALL')        else:            time.sleep(2)    imap.close()